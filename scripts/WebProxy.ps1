#!/usr/bin/env pwsh
<#
# Interesting reference material: https://github.com/jpetazzo/squid-in-a-can
#
#$ This is a web proxy script, it will eventually be a proxy to handle windows authentication to a sharepoint server seemlessly for a tool that does not support authentication. Eventual goal is to also have this set up as an inline transparent proxy that handles caching too.
#
# TODO: figure out how to bind to non localhost without admin access on a non privileged port. This is the error:
# > .\WebProxy.ps1
# MethodInvocationException: C:\Users\\WebProxy.ps1:56:1
# Line |
#   56 |  $listener.Start()
#      |  ~~~~~~~~~~~~~~~~~
#      | Exception calling "Start" with "0" argument(s): "Access is denied."
#
# License: All rights reserved. This code is not licensed for use by anyone other than the author.
# Copyright: OperativeThunny (C) 2023.
#
# TODO: this code's foundational structure is broken because it was generated by ChatGPT. 
It needs to be changed so it can actually handle HTTP requests in a multithreaded manner. there is no method on $runspacePool for QueueScriptBlock.
#>

using namespace System.Net

# Create the runspace pool with the desired number of threads
$minThreads = 1
$maxThreads = 10
$runspacePool = [runspacefactory]::CreateRunspacePool($minThreads, $maxThreads)
$runspacePool.Open()


# Create a script block for processing each request
$processRequestScript = {
    param([HttpListenerContext]$context)
    #param($context)

    Write-Host -BackgroundColor Green "Handling an incoming HTTP request!"

    try {
        # Get the original destination host and port

        # TODO: Do more parsing to be able to handle any port and proto (tls) etc... here and where the webrequest is created to the destination server:
        $destinationHost = $context.Request.Headers["Host"]
        $destinationPort = $context.Request.Url.Port

        # Create a new HTTP request to the original destination
        $proxyRequest = [WebRequest]::Create("http://${destinationHost}:${destinationPort}" + $context.Request.Url.PathAndQuery)
        $proxyRequest.Method = $context.Request.HttpMethod
        $proxyRequest.ContentType = $context.Request.ContentType

        # Copy headers from the original request to the proxy request
        foreach ($header in $context.Request.Headers) {
            if ($header -ne "Host") {
                $proxyRequest.Headers.Add($header, $context.Request.Headers[$header])
            }
        }

        # Get the response from the original destination
        $proxyResponse = $proxyRequest.GetResponse()

        # Copy headers from the proxy response to the original response
        foreach ($header in $proxyResponse.Headers) {
            $context.Response.Headers.Add($header, $proxyResponse.Headers[$header])
        }

        # Copy the response content from the proxy response to the original response
        $stream = $proxyResponse.GetResponseStream()
        $stream.CopyTo($context.Response.OutputStream)
        $stream.Close()

        $context.Response.Close()
    }
    catch {
        # Handle any exceptions that occur during the proxying process
        $context.Response.Write("YOU DONE MESSED UP, A-A-RON: $($_ | ConvertTo-Json)")
        $context.Response.StatusCode = 500
        $context.Response.Close()
    }

    $context.Dispose()
}


try {
    # Create an HTTP listener and start it
    #$listener = New-Object System.Net.HttpListener
    $listener = [HttpListener]::new()
    $listener.Prefixes.Add("http://127.0.0.1:8080/")
    #$listener.Prefixes.Add("https://localhost:8443/")
    # $listener.Prefixes.Add("http://+:8080/")
    # $listener.Prefixes.Add("https://+:8443/")
    #$listener.Prefixes.Add("https://localhost:8080/")
    $listener.Start()

    Write-Host "Proxy server started. Listening on $($listener.Prefixes -join ', ')"
    write-host $(ConvertTo-Json -InputObject $runspacePool.GetAvailableRunspaces())
    # Process incoming requests
    while ($listener.IsListening) {
        # Check if a request is available within a timeout
        if ($listener.BeginGetContext({
            Param($asyncResult)

            Write-Host -BackgroundColor Yellow "Inside begin get context."

            # Get the listener that was used to process the request
            $listener = $asyncResult.AsyncState

            # Accept the incoming connection
            #$listener.EndGetContext($asyncResult)
            $context = $listener.EndGetContext($asyncResult)

            # Assign a default runspace to the current thread
            [Runspace]::DefaultRunspace = $runspacePool.GetRunspace()

            # Invoke the request processing function
            #ProcessRequest $context
            $runspacePool.QueueScriptBlock($processRequestScript, $context)
        }, $listener).AsyncWaitHandle.WaitOne(100)) {
            Write-Host "An incoming request has triggered the asynch begin get context."
            # # Accept the incoming connection
            # $context = $listener.EndGetContext($listener.BeginGetContext({ }, $listener))

            # #$runspacePool.GetAvailableRunspaces()
            #  # Assign a default runspace to the current thread
            # [Runspace]::DefaultRunspace = $runspacePool.GetRunspace()

            # # Submit the request processing to the runspace pool
            # $runspacePool.QueueScriptBlock($processRequestScript, $context)
        }
    }
}
catch {
    Write-Host -BackgroundColor Red "An error occurred while processing the request!"
    Write-Host -BackgroundColor Red $_.Exception.Message
}
finally {
    Write-Host -BackgroundColor Red "The proxy server shall now stop, close, and dispose!"
    # Stop the listener when done
    $listener.Stop()

    # Close the runspace pool
    $runspacePool.Close()
    $runspacePool.Dispose()
}






# Here is some code stolen from the internet that I may use later:
# https://gist.github.com/nobodyguy/9950375
# There is an updated version of this code: https://gist.github.com/mark05e/089b6668895345dd274fe5076f8e1271
# $ServerThreadCode = {
#     $listener = New-Object System.Net.HttpListener
#     $listener.Prefixes.Add('http://+:8008/')

#     $listener.Start()

#     while ($listener.IsListening) {

#         $context = $listener.GetContext() # blocks until request is received
#         $request = $context.Request
#         $response = $context.Response
#         $message = "Testing server"

#         # This will terminate the script. Remove from production!
#         if ($request.Url -match '/end$') { break }

#         [byte[]] $buffer = [System.Text.Encoding]::UTF8.GetBytes($message)
#         $response.ContentLength64 = $buffer.length
#         $response.StatusCode = 500
#         $output = $response.OutputStream
#         $output.Write($buffer, 0, $buffer.length)
#         $output.Close()
#     }

#     $listener.Stop()
# }

# $serverJob = Start-Job $ServerThreadCode
# Write-Host "Listening..."
# Write-Host "Press Ctrl+C to terminate"

# [console]::TreatControlCAsInput = $true

# # Wait for it all to complete
# while ($serverJob.State -eq "Running")
# {
#      if ([console]::KeyAvailable) {
#         $key = [system.console]::readkey($true)
#         if (($key.modifiers -band [consolemodifiers]"control") -and ($key.key -eq "C"))
#         {
#             Write-Host "Terminating..."
#             $serverJob | Stop-Job
#             Remove-Job $serverJob
#             break
#         }
#     }

#     Start-Sleep -s 1
# }

# # Getting the information back from the jobs
# Get-Job | Receive-Job
########################
# This was from the internet as well:
# From: https://stackoverflow.com/questions/56058924/httplistener-asynchronous-handling-with-powershell-new-scriptblockcallback-s
# function New-ScriptBlockCallback
# {
#     [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]
#     param(
#         [parameter(Mandatory)]
#         [ValidateNotNullOrEmpty()]
#         [scriptblock]$Callback
#     )

#     # Is this type already defined?
#     if (-not ( 'CallbackEventBridge' -as [type])) {
#         Add-Type @'
#             using System;

#             public sealed class CallbackEventBridge {
#                 public event AsyncCallback CallbackComplete = delegate { };

#                 private CallbackEventBridge() {}

#                 private void CallbackInternal(IAsyncResult result) {
#                     CallbackComplete(result);
#                 }

#                 public AsyncCallback Callback {
#                     get { return new AsyncCallback(CallbackInternal); }
#                 }

#                 public static CallbackEventBridge Create() {
#                     return new CallbackEventBridge();
#                 }
#             }
# '@
#     }
#     $bridge = [callbackeventbridge]::create()
#     Register-ObjectEvent -InputObject $bridge -EventName callbackcomplete -Action $Callback -MessageData $args > $null
#     $bridge.Callback
# }