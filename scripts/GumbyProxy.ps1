#!/usr/bin/env pwsh
<#
G U M B Y P R O X Y
GumbyProxy is a flexible web proxy that can be used to intercept and modify HTTP requests and responses, perform caching, and act as either a forward proxy or a reverse proxy providing caching capabilities.
It is written in PowerShell and uses the .NET HttpListener class to listen for incoming HTTP requests. 
It is designed to be used as a local proxy server, but can also be used as a gateway proxy server. 
It is named after Gumby, the flexible clay character from the 1950s children's television show The Howdy Doody Show, and also named after the Monty Python sketch Gumby Brain Specialist.
#>
<#
# Interesting reference material: https://github.com/jpetazzo/squid-in-a-can
#
#$ This is a web proxy script, it will eventually be a proxy to handle windows authentication to a sharepoint server seemlessly for a tool that does not support authentication. Eventual goal is to also have this set up as an inline transparent proxy that handles caching too.
#
# TODO: figure out how to bind to non localhost without admin access on a non privileged port. This is the error:
# > .\WebProxy.ps1
# MethodInvocationException: C:\Users\\WebProxy.ps1:56:1
# Line |
#   56 |  $listener.Start()
#      |  ~~~~~~~~~~~~~~~~~
#      | Exception calling "Start" with "0" argument(s): "Access is denied."
#
# License: All rights reserved. This code is not licensed for use by anyone other than the author.
# Copyright: OperativeThunny (C) 2023.
#
# TODO: this code's foundational structure is broken because it was generated by ChatGPT. 
It needs to be changed so it can actually handle HTTP requests in a multithreaded manner. there is no method on $runspacePool for QueueScriptBlock.
#>

using namespace System.Net

# Create the runspace pool with the desired number of threads
$minThreads = 1
$maxThreads = 10
$runspacePool = [runspacefactory]::CreateRunspacePool($minThreads, $maxThreads)
$runspacePool.Open()

# For this function info see https://stackoverflow.com/questions/16281955/using-asynccallback-in-powershell and the links in the comments.
function New-ScriptBlockCallback
{
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]
    param(
        [parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [scriptblock]$Callback
    )
    # https://web.archive.org/web/20160404214529/http://poshcode.org/1382
    # 
<#
    .SYNOPSIS
        Allows running ScriptBlocks via .NET async callbacks.
 
    .DESCRIPTION
        Allows running ScriptBlocks via .NET async callbacks. Internally this is
        managed by converting .NET async callbacks into .NET events. This enables
        PowerShell 2.0 to run ScriptBlocks indirectly through Register-ObjectEvent.        
 
    .PARAMETER Callback
        Specify a ScriptBlock to be executed in response to the callback.
        Because the ScriptBlock is executed by the eventing subsystem, it only has
        access to global scope. Any additional arguments to this function will be
        passed as event MessageData.
       
    .EXAMPLE
        You wish to run a scriptblock in reponse to a callback. Here is the .NET
        method signature:
       
        void Bar(AsyncCallback handler, int blah)
       
        ps> [foo]::bar((New-ScriptBlockCallback { ... }), 42)                        
 
    .OUTPUTS
        A System.AsyncCallback delegate.
#>
    # Is this type already defined?
    if (-not ( 'CallbackEventBridge' -as [type])) {
        Add-Type @' 
        using System; 

        public sealed class CallbackEventBridge { 
            public event AsyncCallback CallbackComplete = delegate { }; 

            private CallbackEventBridge() {} 

            private void CallbackInternal(IAsyncResult result) { 
                CallbackComplete(result); 
            } 

            public AsyncCallback Callback { 
                get { return new AsyncCallback(CallbackInternal); } 
            } 

            public static CallbackEventBridge Create() { 
                return new CallbackEventBridge(); 
            } 
        } 
'@
    }
    $bridge = [callbackeventbridge]::create()
    Register-ObjectEvent -InputObject $bridge -EventName callbackcomplete -Action $Callback -MessageData $args > $null
    $bridge.Callback
}

# Create a script block for processing each request
$processRequestScript = {
    param(
        [HttpListenerContext]$context
    )
    #param($context)

    Write-Host -BackgroundColor Green "Handling an incoming HTTP request!"

    try {
        # Get the original destination host and port

        # TODO: Do more parsing to be able to handle any port and proto (tls) etc... here and where the webrequest is created to the destination server:
        $destinationHost = $context.Request.Headers["Host"]
        $destinationPort = $context.Request.Url.Port

        # Create a new HTTP request to the original destination
        $proxyRequest = [WebRequest]::Create("http://${destinationHost}:${destinationPort}" + $context.Request.Url.PathAndQuery)
        $proxyRequest.Method = $context.Request.HttpMethod
        $proxyRequest.ContentType = $context.Request.ContentType

        # Copy headers from the original request to the proxy request
        foreach ($header in $context.Request.Headers) {
            if ($header -ne "Host") {
                $proxyRequest.Headers.Add($header, $context.Request.Headers[$header])
            }
        }

        # Get the response from the original destination
        $proxyResponse = $proxyRequest.GetResponse()

        # Copy headers from the proxy response to the original response
        foreach ($header in $proxyResponse.Headers) {
            $context.Response.Headers.Add($header, $proxyResponse.Headers[$header])
        }

        # Copy the response content from the proxy response to the original response
        $stream = $proxyResponse.GetResponseStream()
        $stream.CopyTo($context.Response.OutputStream)
        $stream.Close()

        $context.Response.Close()
    }
    catch {
        # Handle any exceptions that occur during the proxying process
        $context.Response.Write("YOU DONE MESSED UP, A-A-RON: $($_ | ConvertTo-Json)")
        $context.Response.StatusCode = 500
        $context.Response.Close()
    }

    $context.Dispose()
}


try {
    # Create an HTTP listener and start it
    #$listener = New-Object System.Net.HttpListener
    $listener = [HttpListener]::new()
    $listener.Prefixes.Add("http://127.0.0.1:8080/")
    #$listener.Prefixes.Add("https://localhost:8443/")
    # $listener.Prefixes.Add("http://+:8080/")
    # $listener.Prefixes.Add("https://+:8443/")
    #$listener.Prefixes.Add("https://localhost:8080/")
    $listener.Start()

    Write-Host "Proxy server started. Listening on $($listener.Prefixes -join ', ')"
    Write-Host "Press Ctrl+C to stop the proxy server."
    # $myCallback = [AsyncCallback]{
    #     param( $asyncResult)
    #     # callback code
    #     if ($asyncResult.isCompleted) {
    #       get-date
    #     }
    #   }    
    # Process incoming requests
    while ($listener.IsListening) {
        # Check if a request is available within a timeout
        $successfullyObtainedBeginListenerContext = $listener.BeginGetContext(
        (New-ScriptBlockCallback {
            Param(
                [PSCustomObject]$asyncContext
            )
            
            if ($asyncContext -eq $null) {
                Write-Host "The asyncContext is null."
                return $false
            }
            
            $asyncResult = $asyncContext.asyncResult
            $processRequestScript = $asyncContext.processRequestScript

            convertto-json $asyncContext
            if ($asyncResult.IsCompleted) {
                Write-Host "The asyncresult is completed."    
            } else {
                Write-Host "exiting the callback because the asyncresult is completed."
                return $false
            }
            Write-Host "Inside begin get context."
            # Get the listener that was used to process the request
            $listener = $asyncResult.AsyncState
            $context = $listener.EndGetContext($asyncResult)
            Start-ThreadJob -ScriptBlock $processRequestScript -ArgumentList $context
        }), [PSCustomObject]@{
            asyncResult = $listener
            processRequestScript = $processRequestScript
        }).AsyncWaitHandle.WaitOne(1000)

        if ($successfullyObtainedBeginListenerContext) {
            Write-Host "An incoming request has triggered the asynch begin get context."
        }
    }
}
catch {
    Write-Host -BackgroundColor Red "An error occurred while processing the request!"
    Write-Host -BackgroundColor Red $_.Exception.Message
}
finally {
    Write-Host -BackgroundColor Red "The proxy server shall now stop, close, and dispose!"
    # Stop the listener when done
    $listener.Stop()

    # Close the runspace pool
    $runspacePool.Close()
    $runspacePool.Dispose()
}

Write-Host 'Done'




# Here is some code stolen from the internet that I may use later:
# https://gist.github.com/nobodyguy/9950375
# There is an updated version of this code: https://gist.github.com/mark05e/089b6668895345dd274fe5076f8e1271
# $ServerThreadCode = {
#     $listener = New-Object System.Net.HttpListener
#     $listener.Prefixes.Add('http://+:8008/')

#     $listener.Start()

#     while ($listener.IsListening) {

#         $context = $listener.GetContext() # blocks until request is received
#         $request = $context.Request
#         $response = $context.Response
#         $message = "Testing server"

#         # This will terminate the script. Remove from production!
#         if ($request.Url -match '/end$') { break }

#         [byte[]] $buffer = [System.Text.Encoding]::UTF8.GetBytes($message)
#         $response.ContentLength64 = $buffer.length
#         $response.StatusCode = 500
#         $output = $response.OutputStream
#         $output.Write($buffer, 0, $buffer.length)
#         $output.Close()
#     }

#     $listener.Stop()
# }

# $serverJob = Start-Job $ServerThreadCode
# Write-Host "Listening..."
# Write-Host "Press Ctrl+C to terminate"

# [console]::TreatControlCAsInput = $true

# # Wait for it all to complete
# while ($serverJob.State -eq "Running")
# {
#      if ([console]::KeyAvailable) {
#         $key = [system.console]::readkey($true)
#         if (($key.modifiers -band [consolemodifiers]"control") -and ($key.key -eq "C"))
#         {
#             Write-Host "Terminating..."
#             $serverJob | Stop-Job
#             Remove-Job $serverJob
#             break
#         }
#     }

#     Start-Sleep -s 1
# }

# # Getting the information back from the jobs
# Get-Job | Receive-Job
########################
# This was from the internet as well:
# From: https://stackoverflow.com/questions/56058924/httplistener-asynchronous-handling-with-powershell-new-scriptblockcallback-s
# function New-ScriptBlockCallback
# {
#     [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]
#     param(
#         [parameter(Mandatory)]
#         [ValidateNotNullOrEmpty()]
#         [scriptblock]$Callback
#     )

#     # Is this type already defined?
#     if (-not ( 'CallbackEventBridge' -as [type])) {
#         Add-Type @'
#             using System;

#             public sealed class CallbackEventBridge {
#                 public event AsyncCallback CallbackComplete = delegate { };

#                 private CallbackEventBridge() {}

#                 private void CallbackInternal(IAsyncResult result) {
#                     CallbackComplete(result);
#                 }

#                 public AsyncCallback Callback {
#                     get { return new AsyncCallback(CallbackInternal); }
#                 }

#                 public static CallbackEventBridge Create() {
#                     return new CallbackEventBridge();
#                 }
#             }
# '@
#     }
#     $bridge = [callbackeventbridge]::create()
#     Register-ObjectEvent -InputObject $bridge -EventName callbackcomplete -Action $Callback -MessageData $args > $null
#     $bridge.Callback
# }